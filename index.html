<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Đề thi Trí tuệ nhân tạo - Từng câu một</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .container {
            width: 100%;
            max-width: 900px;
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            overflow: hidden;
        }
        .header {
            background: linear-gradient(135deg, #ff6b6b, #ee5a24);
            color: white;
            padding: 30px;
            text-align: center;
        }
        .header h1 { font-size: 2.2em; text-shadow: 2px 2px 4px rgba(0,0,0,0.3); }
        .quiz-content { padding: 30px; }
        .progress-container {
            width: 100%;
            background-color: #e0e0e0;
            border-radius: 10px;
            margin-bottom: 20px;
            overflow: hidden;
        }
        .progress-bar {
            height: 10px;
            width: 0%;
            background-color: #764ba2;
            border-radius: 10px;
            transition: width 0.4s ease;
        }
        #quiz-area { min-height: 400px; }
        .question { padding: 10px 0; }
        .question-header { display: flex; align-items: center; margin-bottom: 20px; gap: 15px; }
        .question-number { background: linear-gradient(135deg, #667eea, #764ba2); color: white; min-width: 40px; height: 40px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-weight: bold; }
        .question-type { color: white; padding: 5px 15px; border-radius: 20px; font-size: 0.9em; font-weight: 500; }
        .question-text { font-size: 1.2em; line-height: 1.6; margin-bottom: 25px; white-space: normal; word-wrap: break-word; overflow-wrap: break-word; }
        .question-image { max-width: 100%; height: auto; margin: 20px 0; border-radius: 10px; box-shadow: 0 4px 8px rgba(0,0,0,0.1); }

        /* Option Styles */
        .options-container, .categories-container { display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 15px; }
        .option, .checkbox-option { background: white; border: 2px solid #ddd; border-radius: 10px; padding: 15px; cursor: pointer; transition: all 0.3s ease; }
        .option:hover, .checkbox-option:hover { border-color: #667eea; background: #f0f2ff; transform: translateY(-2px); }
        .option.selected, .checkbox-option.selected { border-color: #667eea; background: linear-gradient(135deg, #667eea, #764ba2); color: white; }
        .checkbox-option { display: flex; align-items: center; }
        .checkbox-option.selected .checkbox { border-color: white; background: white; }
        .checkbox-option.selected .checkbox::after { content: '✓'; color: #667eea; font-weight: bold; }
        .checkbox { width: 20px; height: 20px; border: 2px solid #aaa; border-radius: 4px; margin-right: 15px; display: flex; align-items: center; justify-content: center; flex-shrink: 0; }
        
        /* Drag & Drop Styles */
        .categorization .question-type { background: #e84393; }
        .matching .question-type { background: #e17055; }
        .drag-blank .question-type { background: #20bf6b; }
        .category { background: #fdf6f9; border-radius: 10px; padding: 20px; }
        .category-title { font-weight: bold; color: #e84393; margin-bottom: 15px; white-space: normal; word-wrap: break-word; overflow-wrap: break-word; }
        .drop-zone { min-height: 80px; border: 2px dashed #e9d5e0; border-radius: 8px; padding: 10px; background: white; transition: all 0.3s ease; }
        .drop-zone.drag-over { border-color: #e84393; background: #fff0f6; }
        .draggable-items-source, .drop-zone { display: flex; flex-wrap: wrap; gap: 10px; align-content: flex-start; margin-top: 15px; padding: 10px; border: 1px solid #f0f0f0; border-radius: 10px; }
        .draggable-item { background: #fff; border: 2px solid; padding: 10px 15px; border-radius: 20px; cursor: grab; white-space: normal; word-wrap: break-word; overflow-wrap: break-word; }
        .categorization .draggable-item { border-color: #e84393; color: #e84393; }
        .matching .draggable-item { border-color: #e17055; color: #e17055; }
        .draggable-item.dragging { opacity: 0.5; }
        
        /* Touch mode styles */
        .draggable-item.touch-mode { cursor: pointer; }
        .draggable-item.touch-mode:hover { transform: scale(1.05); }
        .draggable-item.touch-mode.selected { 
            transform: scale(1.1); 
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
            z-index: 10;
            position: relative;
        }
        .drop-zone.touch-mode { cursor: pointer; }
        .drop-zone.touch-mode:hover { border-color: #667eea; background: #f0f2ff; }
        .drop-zone.touch-mode.selected { border-color: #667eea; background: #e8f0ff; }
        
        /* Remove button for mobile */
        .draggable-item.remove-btn {
            position: relative;
        }
        .draggable-item.remove-btn::after {
            content: '✕';
            position: absolute;
            top: -8px;
            right: -8px;
            background: #e74c3c;
            color: white;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: bold;
            cursor: pointer;
            z-index: 20;
        }
        
        /* Mobile hint styling */
        .mobile-hint {
            background: #e8f4fd;
            border: 1px solid #b3d9ff;
            border-radius: 8px;
            padding: 10px;
            margin: 10px 0;
            color: #0066cc;
        }
        
        /* Mobile responsive */
        @media (max-width: 768px) {
            .draggable-item { padding: 12px 16px; font-size: 0.95em; }
            .drop-zone { min-height: 60px; padding: 8px; }
            .matching-premise { flex-direction: column; gap: 10px; }
            .matching-drop-zone { width: 100%; }
        }
        
        /* Matching Layout */
        .matching-premise { display: flex; align-items: center; gap: 15px; background: #fff9f5; padding: 15px; border-radius: 10px; margin-bottom: 10px; }
        .matching-premise-text { flex-grow: 1; font-weight: 500; white-space: normal; word-wrap: break-word; overflow-wrap: break-word; }
        .matching-drop-zone { min-height: 50px; width: 300px; flex-shrink: 0; }
        /* Drag-blank */
        .blank-drop-zone { display: inline-flex; min-width: 160px; min-height: 38px; border: 2px dashed #c8f5dc; border-radius: 8px; padding: 4px 8px; vertical-align: middle; background: #f8fffb; margin: 0 6px; white-space: normal; word-wrap: break-word; overflow-wrap: break-word; }
        .drag-blank .draggable-item { border-color: #20bf6b; color: #20bf6b; }
        .token { background: #20bf6b; color: white; padding: 2px 8px; border-radius: 12px; font-size: 0.9em; white-space: normal; word-wrap: break-word; overflow-wrap: break-word; }
        
        /* Navigation */
        .quiz-navigation { display: flex; justify-content: space-between; align-items: center; margin-top: 30px; }
        .nav-btn, .submit-btn-final { background: #fff; color: #764ba2; border: 2px solid #764ba2; padding: 10px 30px; font-size: 1em; border-radius: 50px; cursor: pointer; transition: all 0.3s ease; }
        .nav-btn:hover, .submit-btn-final:hover { background: #764ba2; color: white; transform: translateY(-2px); }
        .nav-btn:disabled { background: #e0e0e0; border-color: #e0e0e0; color: #aaa; cursor: not-allowed; }
        .progress-text { font-size: 1.1em; font-weight: 500; color: #555; }
        
        /* Results */
        .results { text-align: center; padding: 40px; }
        .score { font-size: 2.5em; font-weight: bold; color: #28a745; }
        .results p { font-size: 1.2em; margin: 15px 0; }
        /* Lock/feedback */
        .feedback { margin-top: 15px; font-weight: 600; }
        .feedback.ok { color: #28a745; }
        .feedback.err { color: #dc3545; }
        .nav-btn[disabled] { opacity: 0.6; }

        /* Overview */
        .overview-container { margin-top: 25px; padding-top: 15px; border-top: 1px solid #eee; }
        .overview-title { font-weight: 600; color: #555; margin-bottom: 10px; }
        .overview-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(44px, 1fr)); gap: 8px; }
        .overview-item { height: 44px; border-radius: 8px; display: flex; align-items: center; justify-content: center; font-weight: 600; cursor: pointer; border: 2px solid transparent; user-select: none; }
        .overview-item.empty { background: #f2f2f2; color: #888; border-color: #e5e5e5; }
        .overview-item.answered { background: #e8f0ff; color: #2952cc; border-color: #b3c6ff; }
        .overview-item.correct { background: #e9f7ef; color: #1e7e34; border-color: #28a745; }
        .overview-item.incorrect { background: #fdecea; color: #c0392b; border-color: #e74c3c; }
        .overview-item.active { box-shadow: 0 0 0 3px rgba(118,75,162,0.2); }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Đề thi Trí tuệ nhân tạo</h1>
        </div>
        
        <div class="quiz-content">
            <div class="progress-container">
                <div class="progress-bar" id="progressBar"></div>
            </div>
            <div id="quiz-area">
                </div>
            <div class="quiz-navigation">
                <button class="nav-btn" id="prevBtn">Câu trước</button>
                <span class="progress-text" id="progressText"></span>
                <button class="nav-btn" id="lockBtn">Chốt đáp án</button>
                <button class="nav-btn" id="nextBtn">Câu sau</button>
            </div>
            <div class="overview-container" id="overviewContainer">
                <div class="overview-title">Tổng quan câu hỏi</div>
                <div class="overview-grid" id="overviewGrid"></div>
            </div>
             <div class="results" id="results" style="display: none;">
                <div class="score" id="score"></div>
                <p>Bạn đã hoàn thành bài thi!</p>
                <button class="nav-btn" onclick="location.reload()">Làm lại từ đầu</button>
            </div>
        </div>
    </div>

    <script>
    document.addEventListener('DOMContentLoaded', function() {
      
           // Mảng câu hỏi về Trí tuệ nhân tạo
const questionsData = [
    { questionNumber: 1, id: 147162, questionType: "select-multiple", questionText: "Trí tuệ nhân tạo có thể được định nghĩa theo những hướng tiếp cận nào?", options: ["A. Hệ thống hành động như người", "B. Hệ thống có thể suy nghĩ như người", "C. Hệ thống chỉ dựa trên lập trình truyền thống", "D. Hệ thống hành động hợp lý"], correctAnswer: ["A", "B", "D"] },
    { questionNumber: 2, id: 147182, questionType: "select-multiple", questionText: "Thị giác máy (computer vision) thuộc thành phần nào của hệ thống AI?(Chọn 2)", options: ["A. Cảm nhận (perception)", "B. Lập luận (reasoning)", "C. Hành động (action)", "D. Xử lý thông tin từ môi trường bên ngoài"], correctAnswer: ["A", "D"] },
    { questionNumber: 3, id: 147183, questionType: "select-multiple", questionText: "Hệ chuyên gia có đặc điểm nào?(chọn 2)", options: ["A. Làm việc dựa trên kinh nghiệm và tri thức của chuyên gia", "B. Đưa ra khuyến cáo, kết luận, chuẩn đoán một cách tự động", "C. Chỉ có thể hoạt động trong lĩnh vực rộng", "D. Không cần tri thức chuyên môn"], correctAnswer: ["A", "B"] },
    { questionNumber: 4, id: 147527, questionType: "select-multiple", questionText: "Vì sao định nghĩa AI theo hướng \"suy nghĩ như con người\" không đủ chính xác trong thiết kế hệ thống AI thực tế?", options: ["A. Không thể đo được mức độ \"suy nghĩ\"", "B. Thiếu cơ sở khoa học chính xác", "C. Con người không phải lúc nào cũng hành động theo logic", "D. Vì AI hiện tại không đủ khả năng nhận thức"], correctAnswer: ["A", "C"] },
    { questionNumber: 5, questionType: "select-multiple", questionText: "Vai trò của AI trong xã hội hiện đại như thế nào?(Chọn 2)", options: ["A. Tạo ra cách làm đơn giản để xây dựng chương trình ra quyết định phức tạp", "B. Chỉ có thể thay thế toàn bộ con người", "C. Không có ý nghĩa thực tiễn", "D. Có khả năng xử lý dữ liệu nhanh hơn và hệ thống hơn con người"], correctAnswer: ["A", "D"] },
    { questionNumber: 6, questionType: "select-multiple", questionText: "Các yếu tố nào sau đây cho thấy giới nghiền cứu AI trong giai đoạn 1966–1973 cán thay đổi cách tiếp cận?(Chọn 2)", options: ["A. Các kỹ thuật tìm kiếm đơn giản không còn phù hợp với bài toán phức tạp", "B. Việc lập trình bằng tay từng quy tắc không khả thi với quy mô lớn", "C. Lập trình hướng đối tượng không phù hợp với các hệ chuyên gia", "D. AI cần được gắn với trí thức và ngữ cảnh chuyên ngành cụ thể"], correctAnswer: ["A", "B"] },
    { questionNumber: 7, questionType: "select-multiple", questionText: "Một nhà nghiên cứu Al đang giải quyết bài toán có không gian tìm kiếm lớn. Những phương pháp nào dưới đây giúp tránh \"bùng nổ tổ hợp\" mà các hệ Al trước đây từng gặp phải? (chọn 2)", options: ["A. Giảm độ chính xác của lời giải để rút gọn thời gian", "B. Áp dụng kỹ thuật heuristic để dân hướng tìm kiếm", "C. Nâng cấp phần cứng thay vì thay đổi thuật toán", "D. Sử dụng thuật toán đệ qui"], correctAnswer: ["A", "B"] },
    { questionNumber: 8, questionType: "select-multiple", questionText: "Trong thực tế, vì sao hướng \"hành động như người\" lại được sử dụng nhiều trong Ai thương mại (như chatbot, robot)?(Chọn 2)", options: ["A. Tập trung vào tương tác và ngôn ngữ", "B. Dề gây thiện cảm với người dùng", "C. Không cần logic hình thức", "D. Không cần học may"], correctAnswer: ["A", "B"] },
    { questionNumber: 9, questionType: "select-multiple", questionText: "Để vượt qua phép thử Turing, hệ thống cần có những khả năng nào? (chọn 2)", options: ["A. Chỉ cần khả năng tính toán nhanh", "B. Biểu diễn trí thức", "C. Học máy", "D. Xử lý ngôn ngữ tự nhiên"], correctAnswer: ["B", "D"] },
    { questionNumber: 10, questionType: "select-multiple", questionText: "Những khả năng nào sau đây một hệ thống cần có để vượt qua phép thử Turing?(Chọn 3)", options: ["A. Học sâu", "B. Xử lý ngôn ngữ tự nhiên", "C. Học máy", "D. Biểu diễn tri thức"], correctAnswer: ["B", "C", "D"] },
    { questionNumber: 11, id: 147208, questionType: "select-multiple", questionText: "Biểu diễn vấn đề trong không gian trạng thái cần xác định những yếu tố nào?  (chọn 3 đáp án đúng nhất)", options: ["A. Trạng thái ban đầu", "B. Tập hợp các toán tử", "C. Chỉ cần xác định trạng thái cuối", "D. Tập hợp các trạng thái kết thúc"], correctAnswer: ["A", "B", "D"] },
    { questionNumber: 12, questionType: "select-multiple", questionText: "Trong tìm kiếm sâu hạn chế, tham số d có ý nghĩa gì ?(Chọn 2)", options: ["A. Giúp tránh bị mắc kẹt ở nhánh vô hạn", "B. Là độ sâu tối đa được phép tìm kiếm", "C. Là thời gian tối đa cho phép", "D. Là số lượng trạng thái tối đa"], correctAnswer: ["A", "B"] },
    { questionNumber: 13, questionType: "select-multiple", questionText: "Tìm kiếm theo chiều rộng có đặc điểm gì? (Chọn 2)", options: ["A. Danh sách L. được xử lý như hàng đợi (queue)", "B. Luôn tìm ra đường đi ngắn nhất nếu có nghiệm", "C. Trạng thái được sinh ra trước sẽ được phát triển trước", "D. Sử dụng ngăn xếp (stack) để lưu trữ"], correctAnswer: ["A", "C"] },
    { questionNumber: 14, questionType: "select-multiple", questionText: "Biểu diễn vấn đề trong không gian trạng thái cần xác định những yếu tố nào? (Chọn 3)", options: ["A. Chỉ cần xác định trạng thái cuối", "B. Trạng thái ban đầu", "C. Tập hợp các trạng thái kết thúc", "D. Tập hợp các toán tử"], correctAnswer: ["B", "C", "D"] },
    { questionNumber: 15, questionType: "select-multiple", questionText: "Cây tìm kiếm có đặc điểm gì? (Chọn 2)", options: ["A. Các đỉnh được gắn bởi các trạng thái của không gian trạng thái", "B. Gốc của cây tương ứng với trạng thái ban đầu", "C. Không thể chứa trạng thái lặp", "D. Chỉ có thể có một đường đi duy nhất"], correctAnswer: ["A", "B"] },
    { questionNumber: 16, questionType: "select-multiple", questionText: "Một bài toán trong trí tuệ nhân tạo được biểu diễn đầy đủ khi xác định các thành phần nào sau đây? (CHọn 3)", options: ["A. Điều kiện dừng", "B. Hàm hành động", "C. Tập trạng thái", "D. Tập hành động"], correctAnswer: ["B", "C", "D"] },
    { questionNumber: 17, questionType: "select-multiple", questionText: "Trong Các bài toán sau, bài toán nào phù hợp hơn khi sử dụng kiêm kinh nghiệm (heuristic) thay vì tìm kiếm mù? (Chọn 3)", options: ["A. Giải bài toán xếp lịch cho một lớp học với nhiều ràng buộc", "B. Bài toán tìm đường ra mê cung không có bản đồ", "C. Bài toán di chuyển quân cờ trên bàn cờ vua, biết rõ vị trí mục tiêu", "D. Bài toán tìm đường đi ngắn nhất trong bản đồ thành phố"], correctAnswer: ["A", "C", "D"] },
    { questionNumber: 18, questionType: "select-multiple", questionText: "Tìm kiếm theo chiều rộng có đặc điểm gì? (Chọn 2)", options: ["A. Danh sách L. được xử lý như hàng đợi (queue)", "B. Luôn tìm ra đường đi ngắn nhất nếu có nghiệm", "C. Trạng thái được sinh ra trước sẽ được phát triển trước", "D. Sử dụng ngăn xếp (stack) để lưu trữ"], correctAnswer: ["A", "C"] },
    { questionNumber: 19, questionType: "select-multiple", questionText: "Biểu diễn vấn đề trong không gian trạng thái cần xác định những yếu tố nào?(Chọn 3)", options: ["A. Chỉ cần xác định trạng thái cuối", "B. Trạng thái ban đầu", "C. Tập hợp các trạng thái kết thúc", "D. Tập hợp các toán tử"], correctAnswer: ["B", "C", "D"] },
    { questionNumber: 20, questionType: "select-multiple", questionText: "Cây tìm kiếm có đặc điểm gì? (Chọn 2)", options: ["A. Các đỉnh được gắn bởi các trạng thái của không gian trạng thái", "B. Gốc của cây tương ứng với trạng thái ban đầu", "C. Không thể chứa trạng thái lặp", "D. Chỉ có thể có một đường đi duy nhất"], correctAnswer: ["A", "B"] },
    { questionNumber: 21, questionType: "select-multiple", questionText: "Đồ thị và/hoặc (AND/OR) được sử dụng để biểu diễn gì?(Chọn 2)", options: ["A. Chỉ các bài toán tối ưu hóa", "B. Việc quy vấn đề về các vấn đề con", "C. Các bài toán không thể phân nhỏ", "D. Các bài toán có thể phân nhỏ thành các bài toán nhỏ hơn"], correctAnswer: ["B", "D"] },
    { questionNumber: 22, questionType: "select-multiple", questionText: "Vì sao biểu diễn bài toán bằng đồ thị thường hiệu quả hơn biểu diễn tuyến tính trong Al?(Chọn 3)", options: ["A. Đảm bảo thuật toán luôn đúng", "B. Cho phép quay lui khi cần", "C. Trực quan hóa tiến trình giải", "D. Thể hiện đầy đủ các trạng thái lặp"], correctAnswer: ["B", "C", "D"] },
    { questionNumber: 23, questionType: "select-multiple", questionText: "Một hệ thống Al sử dụng hàm đánh giá khi: (Chọn 2)", options: ["A. Không có trạng thái đích rõ ràng", "B. Chỉ có duyệt tuyến tính", "C. Cần tìm kiếm có hiệu quả hơn", "D. Cần dần hướng để chọn bước đi tốt hơn"], correctAnswer: ["C", "D"] },
    { questionNumber: 24, questionType: "select-multiple", questionText: "Những hạn chế nào sau đây có thể xảy ra khi sử dụng tìm kiếm mù trong các bài toán thực tế?(Chọn 3)", options: ["A. Mất nhiều thời gian do mở rộng trạng thái không liên quan", "B. Tiêu tốn nhiều bộ nhớ nếu không kiểm soát không gian trạng thái", "C. Có thể không tìm ra lời giải do lập trạng thái", "D. Cần phải xây dựng hệ thống đánh giá phức tạp"], correctAnswer: ["A", "B", "C"] },
    { questionNumber: 25, id: 147907, questionType: "select-multiple", questionText: "Hàm đánh giá h(u) trong tìm kiếm kinh nghiệm có tác dụng gì? Chọn 2 đáp án đúng nhất", options: ["A. Đánh giá \"sự gần đích\" của trạng thái u", "B. Hướng dẫn sự tìm kiếm bằng cách chọn trạng thái có nhiều hứa hẹn nhất", "C. Tính toán chi phí chính xác từ u đến đích", "D. Không có tác dụng gì trong quá trình tìm kiếm"], correctAnswer: ["A", "B"] },
    { questionNumber: 26, id: 147908, questionType: "select-multiple", questionText: "Tìm kiếm tốt nhất - đầu tiên có đặc điểm gì? Chọn 2 đáp án đúng nhất", options: ["A. Là tìm kiếm theo chiều rộng được hướng dẫn bởi hàm đánh giá", "B. Chọn đỉnh có giá trị hàm đánh giá nhỏ nhất để phát triển", "C. Luôn phát triển tất cả đỉnh ở cùng một mức", "D. Không cần sắp xếp danh sách các trạng thái"], correctAnswer: ["A", "B"] },
    { questionNumber: 27, id: 147920, questionType: "select-multiple", questionText: "Ưu điểm của tìm kiếm kinh nghiệm so với tìm kiếm mù là gì? Chọn 2 đáp án đúng nhất", options: ["A. Hàm đánh giá được tính bằng chi phí từ đỉnh hiện thời tới trạng thái đích", "B. Thường nhanh hơn và hiệu quả hơn", "C. Luôn tìm ra nghiệm tối ưu", "D. Không cần xây dựng hàm đánh giá"], correctAnswer: ["A", "B"] },
    { questionNumber: 28, id: 147989, questionType: "select-multiple", questionText: "Đâu là vai trò chính của hàm đánh giá trong các chiến lược tìm kiếm kinh nghiệm? Chọn 2 đáp án đúng nhất", options: ["A. Làm cho tìm kiếm nhanh hơn nhờ hướng dẫn đi đúng hướng", "B. Dùng để tính chi phí thực tế đã đi từ trạng thái ban đầu", "C. Được dùng để quyết định đỉnh nào sẽ được phát triển tiếp theo", "D. Là công cụ thay thế hoàn toàn thuật toán tìm kiếm theo chiều sâu"], correctAnswer: ["A", "C"] },
    { questionNumber: 29, id: 148014, questionType: "select-multiple", questionText: "Trong beam search với k = 2, tại bước đầu tiên, vì sao A và E được chọn? Chọn 2 đáp án đúng nhất", imageUrl: "beam_search_image.png", options: ["A. Vì chúng là 2 node đầu tiên theo thứ tự từ điển", "B. Vì chúng có điểm số cao nhất trong 5 nhánh đầu tiên", "C. Vì chúng tạo ra nhiều node con hơn so với node khác", "D. Vì các node khác có điểm thấp hơn: C = -123, D = -23, B = -11.4"], correctAnswer: ["B", "D"] },
    { questionNumber: 30, id: 147914, questionType: "select-multiple", questionText: "Tìm kiếm leo đồi có đặc điểm gì? Chọn 2 đáp án đúng nhất", options: ["A. Là tìm kiếm theo độ sâu được hướng dẫn bởi hàm đánh giá", "B. Có thể tìm ra nghiệm ở không gian vô hạn", "C. Luôn tìm ra nghiệm tối ưu toàn cục", "D. Có thể mắc kẹt ở độ sâu vô hạn của cây tìm kiếm"], correctAnswer: ["A", "B"] },
    { questionNumber: 31, id: 147987, questionType: "select-multiple", questionText: "Những đặc điểm nào sau đây đúng với hàm đánh giá h(u) trong tìm kiếm kinh nghiệm? Chọn 3 đáp án đúng nhất", options: ["A. h(u) càng nhỏ thì trạng thái u càng gần đích", "B. h(u) dùng để đo khoảng cách từ trạng thái u đến trạng thái đích", "C. h(u) càng lớn thì trạng thái u được ưu tiên phát triển trước", "D. h(u) có thể dẫn đến sai lầm nếu không được thiết kế đúng"], correctAnswer: ["A", "B", "D"] },
    { questionNumber: 32, id: 147995, questionType: "select-multiple", questionText: "Trong thuật toán tìm kiếm tốt nhất - đầu tiên, những đặc điểm nào sau đây là đúng? Chọn 2 đáp án đúng nhất", options: ["A. Chọn trạng thái có giá trị h(u) nhỏ nhất để phát triển tiếp", "B. Luôn phát triển tất cả các trạng thái ở cùng một mức như tìm kiếm theo bề rộng", "C. Có thể phát triển trạng thái ở mức sâu hơn nếu h(u) nhỏ", "D. Không dùng bất kỳ thông tin nào ngoài thứ tự các mức"], correctAnswer: ["A", "C"] },
    { questionNumber: 33, id: 148030, questionType: "select-multiple", questionText: "Về chiến lược lựa chọn trạng thái để phát triển tiếp theo, sự khác nhau giữa hai thuật toán Hill-Climbing và Best-First Search? Chọn 2 đáp án đúng nhất", options: ["A. Hill-Climbing chỉ chọn trạng thái tốt nhất trong số các con của trạng thái hiện tại", "B. Best-First Search có thể chọn lại trạng thái cũ nếu nó có hàm đánh giá tốt nhất", "C. Hill-Climbing có thể phát triển nhiều trạng thái cùng lúc", "D. Best-First Search sử dụng toàn bộ trạng thái trong không gian tìm kiếm để ra quyết định"], correctAnswer: ["A", "D"] },
    { questionNumber: 34, questionType: "select-multiple", questionText: "Định được đánh dấu \"khi nào?\"(chọn 2)", options: ["A. Là đỉnh kết thúc", "B. Không có đỉnh nào", "C. Có ít nhất một toán từ mà tất cả các đỉnh kể theo toán từ đó đều giải được", "D. Có tất cả các toán từ đều dẫn đến đỉnh giải được"], correctAnswer: ["A", "C"] },
    { questionNumber: 35, questionType: "select-multiple", questionText: "Quá trình phát triển trạng thái trong tim ấy có nghĩa là gì?(Chọn 2)", options: ["A. Chỉ đi chuyển đến một trạng thái khác", "B. Tìm tất cả các trạng thái có thể đạt được từ trạng thái hiện tại", "C. Xóa bỏ trạng thái hiện tại", "D. Áp dụng các toán tử để sinh ra các trạng thái kế"], correctAnswer: ["B", "D"] },
    { questionNumber: 36, questionType: "select-multiple", questionText: "Hạn chế của tìm kiếm kinh nghiệm là gì?(Chọn 2)", options: ["A. Có thể đến kết quả nếu có đủ điều kiện", "B. Phụ thuộc vào chất lượng của hàm đánh giá", "C. Luôn chậm hơn tim kiếm mù (lặp từ, chữ bị sai)", "D. Không thể áp dụng cho bài toán thực tế"], correctAnswer: ["A", "B"] },
    { questionNumber: 37, id: 148309, questionType: "select-multiple", questionText: "Ưu điểm của thuật toán nhánh và cận so với tìm kiếm mù là gì? (Chọn 2 đáp án đúng nhất)", options: ["A. Loại bỏ được các nhánh không triển vọng", "B. Giảm đáng kể không gian tìm kiếm", "C. Luôn phải khám phá tất cả các khả năng", "D. Thuật toán nhánh và cận không sử dụng hà"], correctAnswer: ["A", "B"] },
    { questionNumber: 38, id: 148758, questionType: "select-multiple", questionText: "Thuật toán A* có những đặc điểm nào? (Chọn 2 đáp án đúng nhất)", options: ["A. Sử dụng hàm tính khoảng cách từ trạng thái ban đầu đến trạng thái hiện tại", "B. Không cần hàm heuristic", "C. Luôn tìm ra đường đi ngắn nhất mà không cần hàm heuristic", "D. h(n) là ước tính chi phí từ đỉnh n đến đích"], correctAnswer: ["A", "D"] },
    { questionNumber: 39, id: 148827, questionType: "select-multiple", questionText: "Bạn lập trình một robot hút bụi di chuyển trong nhà. Robot cần đi từ vị trí A đến G, tránh các vật cản.Biết khoảng cách thực tế giữa các phòng và h(n) là khoảng cách ước lượng từ n đến G theo đường thẳng.Chọn các đặc điểm đúng về việc áp dụng A* trong trường hợp này. (Chọn 3 đáp án đúng nhất)", options: ["A. A* có thể dẫn robot đi theo đường vòng nếu h(n) đánh giá sai", "B. Nếu h(n) chấp nhận được, robot sẽ đi đường tối ưu", "C. h(n) cần phản ánh đúng không gian (có tường, vật cản)", "D. Nếu h(n)=0, robot sẽ chọn bất kỳ đường nào miễn gần"], correctAnswer: ["A", "B", "C"] },
    { questionNumber: 40, id: 148865, questionType: "select-multiple", questionText: "Bạn đang lập lịch thi cho một trường đại học sao cho không có hai môn thi trùng giờ với sinh viên trùng lớp. Bạn dùng thuật toán nhánh và cận để giảm không gian tìm kiếm. Lợi ích nào sau đây là hợp lý khi sử dụng nhánh và cận trong bài toán này? (Chọn 3 đáp án đúng nhất)", options: ["A. Có thể loại bỏ nhanh các lịch thi không hợp lệ mà không cần kiểm tra toàn bộ", "B. Giảm số lượng tổ hợp cần xét bằng cách đánh giá sớm tính khả thi", "C. Luôn đảm bảo có ít môn thi nhất", "D. Đảm bảo kiểm tra toàn bộ không gian lời giải để tìm phương án tối ưu"], correctAnswer: ["A", "B", "D"] },
    { questionNumber: 41, id: 148930, questionType: "select-multiple", questionText: "Trong bài toán phân công công việc cho 5 nhân viên với 5 nhiệm vụ sao cho tổng chi phí là thấp nhất, bạn áp dụng thuật toán nhánh và cận. Tại sao nhánh và cận phù hợp cho bài toán này? (Chọn 3 đáp án đúng nhất)", options: ["A. Vì không gian tìm kiếm dạng tổ hợp, có thể cắt bỏ nhánh kém hiệu quả", "B. Vì mỗi nhánh tương ứng với một phân công tạm thời", "C. Vì luôn tồn tại chiến lược chọn nhân viên tốt nhất cho mỗi nhiệm vụ", "D. Vì có thể tính cận dưới để dừng sớm các nhánh kém"], correctAnswer: ["A", "B", "D"] },
    { questionNumber: 42, id: 148871, questionType: "select-multiple", questionText: "Một nhà máy cần xếp hàng hóa lên xe tải sao cho tổng khối lượng không vượt quá tải trọng, và tổng giá trị hàng là lớn nhất. Họ dùng thuật toán nhánh và cận. Chọn nhận định đúng về hiệu quả khi áp dụng thuật toán nhánh và cận: (Chọn 3 đáp án đúng nhất)", options: ["A. Giải quyết bài toán tương tự như Balo (Knapsack)", "B. Có thể dừng sớm nhánh nếu tổng trọng lượng vượt giới hạn", "C. Không đảm bảo tìm được nghiệm nếu cận trên không được tính chính xác", "D. Thời gian thực thi phụ thuộc vào chiến lược chọn nhánh mở rộng"], correctAnswer: ["A", "B", "D"] },
    { questionNumber: 43, id: 148767, questionType: "select-multiple", questionText: "Chọn các đặc điểm đúng về hàm heuristic h(u) trong tìm kiếm tối ưu: (Chọn 3 đáp án đúng nhất)", options: ["A. Là hàm đo khoảng cách thực sự từ u đến đích.", "B. Là hàm đánh giá thấp nếu h(u) ≤ khoảng cách thật đến đích.", "C. Có thể ảnh hưởng đến tính tối ưu của thuật toán nếu không được thiết kế đúng.", "D. Luôn phải bằng 0 ở trạng thái đích."], correctAnswer: ["B", "C", "D"] },
    { questionNumber: 44, id: 148833, questionType: "select-multiple", questionText: "Trong một hệ thống chỉ đường xe buýt thông minh, A* được dùng để tìm tuyến đi nhanh nhất từ điểm A đến G dựa trên thời gian thực tế và khoảng cách ước lượng. Điều nào sau đây là đúng khi triển khai A* cho hệ thống này? (Chọn 2 đáp án đúng nhất)", options: ["A. Nếu h(n) không tính đến kẹt xe, đường đi tìm được có thể không tối ưu", "B. Nếu g(n) được cập nhật liên tục theo dữ liệu giao thông, A* sẽ phản ứng tốt với thay đổi", "C. A* vẫn đảm bảo tìm được lời giải nếu h(n) không chấp nhận được", "D. A* phù hợp với bài toán có nhiều mục tiêu di chuyển đồng thời"], correctAnswer: ["A", "B"] },
    { questionNumber: 45, id: 148841, questionType: "select-multiple", questionText: "Trong một ứng dụng chỉ đường xe tự hành trong kho hàng, xe cần tìm đường từ vị trí A đến G trong khi tránh các kệ hàng và vật cản.Biết: g(n): khoảng cách thực tế đã đi; h(n): khoảng cách ước lượng đến GKhi nào A* cho kết quả tối ưu nhất trong bài toán này? (Chọn 3 đáp án đúng nhất)", options: ["A. Khi h(n) đánh giá đúng hoặc thấp hơn khoảng cách thực tế đến đích", "B. Khi môi trường không thay đổi trong quá trình di chuyển", "C. Khi g(n) và h(n) đều được cập nhật theo thời gian thực", "D. Khi h(n) lớn hơn thực tế để giảm số nút mở rộng"], correctAnswer: ["A", "B", "C"] },
    { questionNumber: 46, questionType: "select-multiple", questionText: "Phát biểu nào sau đây là đúng về các hàm đánh giá trong tìm kiếm tối ưu?(Chọn 3 phương án đúng nhất)", options: ["A. Hàm h(u) là ước lượng khoảng cách từ u đến trạng thái đích.", "B. Hàm f(u) càng nhỏ thì nút u càng được ưu tiên mở rộng.", "C. Hàm h(u) phải luôn đánh giá lớn hơn độ dài thực tế đến đích để đảm bảo tối ưu.", "D. Hàm g(u) là độ dài đường đi từ trạng thái ban đầu đến u."], correctAnswer: ["A", "B", "D"] },
    { questionNumber: 47, questionType: "select-multiple", questionText: "Một hệ thống định tuyến mạng viễn thông sử dụng thuật toán A* để xác định đường truyền dữ liệu tối ưu từ máy chủ A đến thiết bị G. Thông tin h(n) được lấy từ độ trễ ước lượng giữa các nút. Những nhận định nào sau đây đúng khi áp dụng A* trong bài toán định tuyến mạng?(chọn 3 phương án đúng nhất)", options: ["A. Nếu h(n) đánh giá quá thấp, A* có thể tốn nhiều thời gian do mở rộng không cần thiết.", "B. Nếu h(n) quá cao, A* có thể bỏ sót đường đi tối ưu.", "C. A* không thể áp dụng cho mạng động (thay đổi thời gian thực).", "D. Nếu h(n)=0 với mọi n, A* trở thành thuật toán Dijkstra."], correctAnswer: ["A", "B", "D"] },
    { questionNumber: 48, id: 149053, questionType: "select-multiple", questionText: "Bạn thiết kế một trò chơi dạng cờ mini với bàn cờ 4x4, và sử dụng Minimax để quyết định nước đi cho máy. Bạn cần xây dựng cây trò chơi. Những yếu tố nào sau đây là đặc điểm của cây trò chơi?(Chọn 3)", options: ["A. Mỗi đỉnh biểu diễn một trạng thái của trò chơi", "B. Mỗi cạnh biểu diễn một nước đi hợp lệ", "C. Lá cây luôn là trạng thái thắng hoặc thua", "D. Mỗi đỉnh phải chứa điểm số của người chơi"], correctAnswer: ["A", "B", "C"] },
    { questionNumber: 49, id: 149070, questionType: "select-multiple", questionText: "Bạn xây dựng phần mềm chơi cờ tướng online giữa người và AI. AI sẽ sử dụng Minimax để lựa chọn nước đi. Trong một lượt chơi, AI sẽ: (Chọn 2)", options: ["A. Lựa chọn nước đi có giá trị đánh giá cao nhất theo hàm eval", "B. Ưu tiên nước đi gần với vị trí quân Tướng của đối thủ", "C. Chạy Minimax để duyệt toàn bộ cây cho đến trạng thái kết thúc", "D. Xét tất cả các nước đi hợp lệ từ trạng thái hiện tại"], correctAnswer: ["A", "D"] },
    { questionNumber: 50, id: 149104, questionType: "select-multiple", questionText: "Bạn là sinh viên ngành Khoa học Máy tính và đang tham gia một bài thực hành về trí tuệ nhân tạo trong môn học \"AI cơ bản\". Nhiệm vụ của bạn là mô phỏng cách ra quyết định của một AI chơi cờ vua. Trong đó, máy tính sử dụng thuật toán Minimax để lựa chọn nước đi tiếp theo. Giáo viên yêu cầu bạn giải thích quy trình hoạt động của thuật toán Minimax trong quá trình tìm kiếm nước đi. Theo bạn, những bước nào sau đây là hợp lý và đúng với bản chất của thuật toán Minimax?(Chọn 3)", options: ["A. Duyệt cây trò chơi từ trạng thái ban đầu (gốc) đến các trạng thái kết thúc (lá) theo thứ tự luân phiên lượt chơi giữa người và máy", "B. Gán giá trị cho các trạng thái kết thúc bằng điểm kết quả hoặc hàm đánh giá trạng thái nếu chưa kết thúc", "C. Quay ngược từ các trạng thái lá về gốc để xác định nước đi tối ưu ở từng nút dựa theo vai trò (Max/Min)", "D. Nếu không chắc chắn trạng thái nào tốt nhất, AI chọn ngẫu nhiên một nước đi trong số các lựa chọn còn lại"], correctAnswer: ["A", "B", "C"] },
    { questionNumber: 51, id: 149215, questionType: "select-multiple", questionText: "Trong một bài kiểm tra kỹ năng chiến lược AI, bạn cần lý giải vì sao Alpha-Beta có thể đưa ra kết quả giống Minimax nhưng nhanh hơn. Chọn phát biểu đúng: (Chọn 2)", options: ["A. Alpha-Beta loại bỏ hoàn toàn nhánh không ảnh hưởng đến quyết định cuối", "B. Alpha-Beta đảm bảo tính tối ưu nếu được duyệt theo thứ tự tốt", "C. Alpha-Beta chỉ xét các lá", "D. Alpha-Beta không cần hàm đánh giá"], correctAnswer: ["A", "B"] },
    { questionNumber: 52, id: 149060, questionType: "select-multiple", questionText: "Bạn lập trình ứng dụng cờ vua AI, trong đó thuật toán Minimax phải dừng tìm kiếm khi đến độ sâu nhất định và sử dụng hàm đánh giá để ước lượng giá trị trạng thái. Những nhận định nào là đúng về vai trò của hàm đánh giá? (Chọn 3 đáp án đúng nhất)", options: ["A. Giúp mô phỏng kết quả mà không cần chơi đến hết ván", "B. Giảm thời gian xử lý bằng cách tránh duyệt toàn bộ cây", "C. Luôn cho kết quả chính xác như trạng thái kết thúc", "D. Được thiết kế dựa trên các yếu tố chiến lược của trò chơi"], correctAnswer: ["A", "B", "D"] },
    { questionNumber: 53, id: 149106, questionType: "select-multiple", questionText: "Một sinh viên lập trình trò chơi cờ caro AI. Khi phân tích thuật toán Minimax với độ sâu d = 4, học sinh nhận ra thời gian chạy rất lâu. Những nguyên nhân nào sau đây là hợp lý? (Chọn 3 đáp án đúng nhất)", options: ["A. Số lượng nước đi hợp lệ quá nhiều tại mỗi bước", "B. Không sử dụng giới hạn độ sâu hoặc cắt tỉa", "C. Không áp dụng hàm đánh giá ở trạng thái trung gian", "D. Do Minimax không hỗ trợ game cờ caro"], correctAnswer: ["A", "B", "C"] },
    { questionNumber: 54, id: 149232, questionType: "select-multiple", questionText: "Bạn đang phát triển ứng dụng AI cho game chiến thuật thời gian thực, với hàng trăm lựa chọn mỗi bước. Cách nào dưới đây giúp mô hình vẫn chọn được nước đi hiệu quả mà không tính toàn bộ cây trạng thái? (Chọn 3 đáp án đúng nhất)", options: ["A. Áp dụng A*", "B. Giới hạn độ sâu và dùng Alpha-Beta", "C. Cắt sớm các nhánh có giá trị chắc chắn không tối ưu", "D. Đánh giá trạng thái lá bằng hàm heuristic"], correctAnswer: ["B", "C", "D"] },
    { questionNumber: 55, id: 149252, questionType: "select-multiple", questionText: "Bạn huấn luyện AI chơi cờ caro với kích thước bảng lớn (15x15), và độ sâu tìm kiếm giới hạn. Để tăng tốc, bạn kết hợp Minimax với Alpha-Beta. Những điều nào sau đây là đúng? (Chọn 3 đáp án đúng nhất)", options: ["A. Alpha-Beta chỉ hiệu quả nếu thứ tự nước đi tốt", "B. Càng nhiều nhánh ở mỗi nút, càng có lợi cho Alpha-Beta", "C. Alpha-Beta có thể dùng kết hợp với giới hạn thời gian", "D. Nếu không dùng Alpha-Beta, thời gian tính toán sẽ gấp nhiều lần"], correctAnswer: ["A", "C", "D"] },
    { questionNumber: 56, id: 149396, questionType: "select-multiple", questionText: "Một người sẽ được nhận nếu họ có bằng cấp và biết Python. Mệnh đề nào sau đây là đúng? Ký hiệu: A(x): x có bằng cấp, B(x): x biết Python, C(x): x được nhận (Chọn 2 đáp án đúng nhất)", options: ["A. ∀x (A(x) ∧ B(x) → C(x))", "B. ∀x (C(x) → A(x) ∧ B(x))", "C. ∃x (A(x) ∧ B(x) ∧ C(x))", "D. ∀x (¬A(x) ∨ ¬B(x) → ¬C(x))"], correctAnswer: ["A", "D"] },
    { questionNumber: 57, id: 149399, questionType: "select-multiple", questionText: "Nếu một người đặt phòng thì họ phải có tài khoản hợp lệ. Biểu diễn nào đúng? Ký hiệu: P(x): x đặt phòng, Q(x): x có tài khoản hợp lệ (Chọn 2 đáp án đúng nhất)", options: ["A. ∀x (P(x) → Q(x))", "B. ∀x (¬Q(x) → ¬P(x))", "C. ∃x (P(x) ∧ ¬Q(x))", "D. ∀x (Q(x) → P(x))"], correctAnswer: ["A", "B"] },
    { questionNumber: 58, id: 149430, questionType: "select-multiple", questionText: "Cho công thức: ∀x (A(x) ∧ B(x) → C(x)) Diễn giải nào là đúng? (Chọn 2 đáp án đúng nhất)", options: ["A. Nếu một người có A và B thì có C", "B. Ai có A và B sẽ có C", "C. Người có C chắc chắn có A và B", "D. Người không có A hoặc không có B sẽ có C"], correctAnswer: ["A", "B"] },
    { questionNumber: 59, id: 149451, questionType: "select-multiple", questionText: "Cho công thức: ∃x ∀y R(x,y) Ý nghĩa nào sau đây là đúng? (Chọn 2 đáp án đúng nhất)", options: ["A. Có một đối tượng liên hệ với tất cả các đối tượng khác", "B. Mỗi đối tượng đều liên hệ với ai đó", "C. Có người biết tất cả", "D. Mọi người đều biết nhau"], correctAnswer: ["A", "C"] },
    { questionNumber: 60, id: 149496, questionType: "select-multiple", questionText: "Tình huống: Trong một bệnh viện, người ta định nghĩa các vị từ như sau: P(x): x là bác sĩ, Q(x): x là người biết cấp cứu, R(x): x có thể trực đêm. Cơ sở tri thức: ∀x (P(x) → Q(x)), ∀x (Q(x) → R(x)), P(A). Những suy diễn nào sau đây là hợp lệ? (Chọn 2 đáp án đúng nhất)", options: ["A. Q(A)", "B. R(A)", "C. (P(x) → R(x))", "D. P(A) → R(B)"], correctAnswer: ["A", "B"] },
    { questionNumber: 61, id: 149498, questionType: "select-multiple", questionText: "Tình huống: Ở một trung tâm đào tạo, các vị từ được định nghĩa như sau: T(x): x là giáo viên, M(x): x biết tiếng Anh, L(x): x có thể dạy lớp quốc tế. Cơ sở tri thức: ∀x (T(x) ∧ M(x) → L(x)), T(B) ∧ M(B). Những suy diễn nào sau đây là hợp lệ? (Chọn 2 đáp án đúng nhất)", options: ["A. L(B)", "B. T(B) → L(B)", "C. ∀x (M(x) → L(x))", "D. ∃x (L(x))"], correctAnswer: ["A", "D"] },
    { questionNumber: 62, id: 149508, questionType: "select-multiple", questionText: "Tình huống: Trong một hệ thống thư viện, định nghĩa các vị từ: R(x): x là người đọc sách thường xuyên, M(x): x có thẻ thành viên, F(x): x được mượn sách đặc biệt. Cơ sở tri thức: ∀x (R(x) → M(x)), ∀x (M(x) → F(x)), R(D). Những suy diễn nào sau đây là hợp lệ? (Chọn 3 đáp án đúng nhất)", options: ["A. M(D)", "B. F(D)", "C. R(D) → F(D)", "D. (R(x) → F(x))"], correctAnswer: ["A", "B", "C"] },
    { questionNumber: 63, id: 149521, questionType: "select-multiple", questionText: "Bạn xây dựng phần mềm quản lý tuyển sinh đại học. Cơ sở dữ liệu định nghĩa như sau: A(x): x nộp hồ sơ, B(x): x trúng tuyển, C(x): x có điểm > 24. Biết rằng: ∀x (C(x) → B(x)), ∀x (B(x) → A(x)), C(Nam). Những suy diễn hợp lệ nào sau đây? (Chọn 2 đáp án đúng nhất)", options: ["A. Nam trúng tuyển", "B. Nam đã nộp hồ sơ", "C. Nếu Nam không nộp hồ sơ thì trúng tuyển", "D. Nếu điểm của Nam = 24 thì không trúng tuyển"], correctAnswer: ["A", "B"] },
    { questionNumber: 64, id: 149783, questionType: "select-multiple", questionText: "Bạn xây dựng hệ thống chẩn đoán y tế dựa trên luật như sau: Luật 1: if bệnh nhân bị sốt and đau họng then bệnh nhân có thể bị viêm họng. Luật 2: if bệnh nhân bị viêm họng then bác sĩ chỉ định xét nghiệm máu. Luật 3: if bệnh nhân sốt cao (>39°C) and run lạnh then bệnh nhân có thể bị cúm. Một bệnh nhân có các triệu chứng: sốt (38.5°C), đau họng. Những kết luận nào sau đây có thể được suy diễn? (Chọn 2 đáp án đúng nhất)", options: ["A. Bệnh nhân bị viêm họng", "B. Bệnh nhân cần xét nghiệm máu", "C. Bệnh nhân bị cúm", "D. Bệnh nhân bị sốt cao"], correctAnswer: ["A", "B"] },
    { questionNumber: 65, id: 149784, questionType: "select-multiple", questionText: "Hệ thống quản lý phương tiện có luật: Luật 1: if xe có 4 bánh and dùng xăng then đó là xe hơi. Luật 2: if xe là xe hơi and xe có gắn logo Toyota then đó là xe Toyota. Luật 3: if xe có 2 bánh then đó là xe máy. Một phương tiện được mô tả: có 4 bánh, dùng xăng, có logo Toyota. Hệ thống sẽ đưa ra các kết luận nào? (Chọn 2 đáp án đúng nhất)", options: ["A. Xe hơi", "B. Xe Toyota", "C. Xe máy", "D. Xe chạy điện"], correctAnswer: ["A", "B"] },
    { questionNumber: 66, id: 149786, questionType: "select-multiple", questionText: "Hệ thống nhận dạng môi trường nguy hiểm có luật: Luật 1: if có khói and có mùi khét then có thể có cháy. Luật 2: if có cháy then kích hoạt báo động. Luật 3: if nhiệt độ tăng nhanh then nghi ngờ cháy. Cảm biến báo: có khói, có mùi khét. Kết luận nào đúng? (Chọn 2 đáp án đúng nhất)", options: ["A. Có cháy", "B. Kích hoạt báo động", "C. Có trộm", "D. Nhiệt độ tăng nhanh"], correctAnswer: ["A", "B"] },
    { questionNumber: 67, id: 149787, questionType: "select-multiple", questionText: "Phần mềm nhà thông minh có luật: Luật 1: if trời tối then bật đèn. Luật 2: if người rời khỏi nhà then tắt điều hòa. Luật 3: if trời mưa then đóng cửa sổ. Tình huống: trời tối, trời mưa, không có người trong nhà. Hệ thống thực hiện gì? (Chọn 3 đáp án đúng nhất)", options: ["A. Bật đèn", "B. Tắt điều hòa", "C. Mở cửa sổ", "D. Đóng cửa sổ"], correctAnswer: ["A", "B", "D"] },
    { questionNumber: 68, id: 149788, questionType: "select-multiple", questionText: "Trong hệ thống quản lý học tập: Luật 1: if học sinh điểm trung bình < 5 then xếp loại yếu. Luật 2: if học sinh xếp loại yếu then gửi email cảnh báo. Luật 3: if học sinh điểm trung bình > 8 then xếp loại giỏi. Một học sinh có điểm trung bình 4.8. Suy luận hợp lý là? (Chọn 2 đáp án đúng nhất)", options: ["A. Học sinh xếp loại giỏi", "B. Học sinh xếp loại yếu", "C. Gửi email cảnh báo", "D. Học sinh đạt học bổng"], correctAnswer: ["B", "C"] },
    { questionNumber: 69, id: 149789, questionType: "select-multiple", questionText: "Trong phần mềm giáo dục môi trường: Luật 1: if cây có lá kim then cây thuộc họ thông. Luật 2: if cây có lá rộng and rụng lá then cây thuộc họ sồi. Luật 3: if cây thuộc họ thông then sống tốt ở vùng lạnh. Cây quan sát có lá kim.Suy diễn nào đúng? (Chọn 2 đáp án đúng nhất)", options: ["A. Cây thuộc họ thông", "B. Cây thuộc họ sồi", "C. Cây sống tốt ở vùng lạnh", "D. Cây không có lá"], correctAnswer: ["A", "C"] },
    { questionNumber: 70, id: 149790, questionType: "select-multiple", questionText: "Trong chatbot chăm sóc khách hàng: Luật 1: if khách than phiền and dùng từ \"tệ\" then đánh giá cảm xúc tiêu cực. Luật 2: if cảm xúc tiêu cực then chuyển cho nhân viên tư vấn. Luật 3: if khách dùng từ \"tốt\" and \"hài lòng\" then đánh giá cảm xúc tích cực. Khách nhắn: \"Dịch vụ quá tệ và chậm trễ\". Chatbot sẽ? (Chọn 2 đáp án đúng nhất)", options: ["A. Đánh giá cảm xúc tiêu cực", "B. Chuyển cho nhân viên tư vấn", "C. Đánh giá cảm xúc tích cực", "D. Gửi mã giảm giá"], correctAnswer: ["A", "B"] },
    { questionNumber: 71, id: 149792, questionType: "select-multiple", questionText: "Cho cơ sở tri thức: R₁: If động vật có 4 chân then động vật là thú. R₂: If động vật có móng guốc and có 2 mông then động vật thuộc họ trâu bò. R₃: If động vật thuộc họ trâu bò and thích chỗ ẩm ướt then động vật là trâu. Cho các sự kiện đã biết: F₁: Bi có 4 chân, F₂: Bi có móng guốc, F₃: Bi có 2 mông, F₄: Bi thích chỗ ẩm ướt. Hãy chọn các bước suy diễn lùi hợp lệ để kiểm tra giả thuyết: \"Bi là trâu\". (Chọn 3 đáp án đúng nhất)", options: ["A. Kiểm tra R₃ và tìm xem Bi có thuộc họ trâu bò và thích ẩm ướt không.", "B. Từ R₂, xác định xem Bi có móng guốc and 2 mông để kết luận Bi thuộc họ trâu bò.", "C. Từ R₁, nếu Bi có 4 chân thì Bi là thú và từ đó suy ra Bi là trâu.", "D. Nếu Bi không có móng guốc thì không thể áp dụng R₂."], correctAnswer: ["A", "B", "D"] },
    { questionNumber: 72, id: 149794, questionType: "select-multiple", questionText: "Cơ sở tri thức: R₁: If trời mưa then đường ướt. R₂: If đường ướt then xe dễ trượt. R₃: If xe dễ trượt and người lái không cẩn thận then có thể gây tai nạn. R4: If trời nắng then ăn kem. Tập sự kiện: F₁: Trời mưa., F₂: Người lái không cẩn thận. Giả thuyết: Có thể gây tai nạn. Những luật nào cần được sử dụng để dẫn đến giả thuyết? (Chọn 3 đáp án đúng nhất)", options: ["A. R₁", "B. R₂", "C. R₃", "D. R4"], correctAnswer: ["A", "B", "C"] },
    { questionNumber: 73, id: 149807, questionType: "select-multiple", questionText: "Cơ sở tri thức: R₁: If người học lập trình and biết giải quyết vấn đề then là kỹ sư phần mềm. R₂: If là kỹ sư phần mềm and có kinh nghiệm then có thể làm việc tại công ty công nghệ. R₃: If biết giải quyết vấn đề then có tư duy logic. Tập sự kiện: F₁: Huy học lập trình., F₂: Huy biết giải quyết vấn đề., F₃: Huy có kinh nghiệm. Kết luận nào có thể được suy ra? (Chọn 3 đáp án đúng nhất)", options: ["A. Huy là kỹ sư phần mềm.", "B. Huy có tư duy logic.", "C. Huy có thể làm việc tại công ty công nghệ.", "D. Huy là giảng viên đại học."], correctAnswer: ["A", "B", "C"] }
];



        let currentQuestionIndex = 0;
        const userAnswers = new Array(questionsData.length).fill(null);
        const quizArea = document.getElementById('quiz-area');
        const nextBtn = document.getElementById('nextBtn');
        const prevBtn = document.getElementById('prevBtn');
        const lockBtn = document.getElementById('lockBtn');
        const progressText = document.getElementById('progressText');
        const progressBar = document.getElementById('progressBar');
        const overviewGrid = document.getElementById('overviewGrid');

        // Shuffle utilities and one-time preparation
        function shuffleArray(arr) {
            for (let i = arr.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [arr[i], arr[j]] = [arr[j], arr[i]];
            }
            return arr;
        }

        // Display helper: hide leading numeric prefixes like "1--", "2 - " for UI only
        function formatVisibleText(text) {
            if (typeof text !== 'string') return text;
            return text.replace(/^\s*\d+\s*[-–—.]*\s*/, '').trim();
        }

        // --- Audio feedback (no external files; uses Web Audio API) ---
        let audioContextInstance = null;
        function getAudioContext() {
            if (!audioContextInstance) {
                const Ctx = window.AudioContext || window.webkitAudioContext;
                if (Ctx) audioContextInstance = new Ctx();
            }
            return audioContextInstance;
        }
        function playTone(frequency, duration = 0.15, type = 'sine', gainValue = 0.06) {
            const ctx = getAudioContext();
            if (!ctx) return;
            const oscillator = ctx.createOscillator();
            const gain = ctx.createGain();
            oscillator.type = type;
            oscillator.frequency.value = frequency;
            gain.gain.value = gainValue;
            oscillator.connect(gain);
            gain.connect(ctx.destination);
            const now = ctx.currentTime;
            oscillator.start(now);
            oscillator.stop(now + duration);
        }
        function playSuccessSound() {
            // small two-note chime
            playTone(880, 0.12, 'sine', 0.08);
            setTimeout(() => playTone(1175, 0.18, 'sine', 0.07), 90);
        }
        function playErrorSound() {
            // brief buzz effect
            for (let i = 0; i < 6; i++) {
                setTimeout(() => playTone(220 + (i % 2 ? 30 : -30), 0.06, 'square', 0.05), i * 60);
            }
        }

        // Convert all fill-in-the-blank to drag-blank for consistent UX
        questionsData.forEach(q => {
            if (q.questionType === 'fill-in-the-blank') q.questionType = 'drag-blank';
        });

        // Randomize the order of questions
        shuffleArray(questionsData);
        // Pre-shuffle options per question to keep stable across renders
        questionsData.forEach(q => {
            if (q.options && Array.isArray(q.options)) {
                if (q.questionType === 'select-multiple') {
                    // For select-multiple, only shuffle the content, keep A,B,C,D labels in order
                    const optionsWithLabels = q.options.map(opt => {
                        const match = opt.match(/^([A-D])\.\s*(.+)$/);
                        if (match) {
                            return { label: match[1], content: match[2] };
                        }
                        return { label: '', content: opt };
                    });
                    
                    // Shuffle only the content, keep labels in A,B,C,D order
                    const shuffledContent = shuffleArray(optionsWithLabels.map(o => o.content));
                    q._optionsShuffled = optionsWithLabels.map((opt, index) => 
                        opt.label ? `${opt.label}. ${shuffledContent[index]}` : shuffledContent[index]
                    );
                    
                    // Create mapping for correct answers: old label -> new label based on content
                    q._answerMapping = {};
                    const originalContentToLabel = {};
                    optionsWithLabels.forEach(opt => {
                        if (opt.label) {
                            originalContentToLabel[opt.content] = opt.label;
                        }
                    });
                    
                    // Map each shuffled content to its new label
                    shuffledContent.forEach((content, newIndex) => {
                        const originalLabel = originalContentToLabel[content];
                        if (originalLabel) {
                            const newLabel = String.fromCharCode(65 + newIndex); // A, B, C, D
                            q._answerMapping[originalLabel] = newLabel;
                        }
                    });
                } else {
                    q._optionsShuffled = shuffleArray([...q.options]);
                }
            }
            // Shuffle category columns order for categorization
            if (q.questionType === 'categorization' && q.correctAnswer && typeof q.correctAnswer === 'object') {
                q._categoriesShuffled = shuffleArray(Object.keys(q.correctAnswer));
            }
            // Shuffle premises order for matching
            if (q.questionType === 'matching' && q.correctAnswer && typeof q.correctAnswer === 'object') {
                q._premisesShuffled = shuffleArray(Object.keys(q.correctAnswer));
            }
        });

        // State for lock-first-attempt grading
        const firstAttemptDone = new Array(questionsData.length).fill(false);
        const firstAttemptCorrect = new Array(questionsData.length).fill(false);
        const canProceed = new Array(questionsData.length).fill(false);
        
        // Touch mode detection and state
        const isTouchDevice = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
        let touchMode = false;
        let selectedItem = null;

        function getQuestionTypeName(type) {
            const types = {'fill-in-the-blank': 'Điền vào chỗ trống', 'drag-blank': 'Kéo thả vào chỗ trống', 'categorization': 'Phân loại', 'select-multiple': 'Chọn nhiều đáp án', 'matching': 'Ghép cặp'};
            return types[type] || type;
        }

        function saveAnswer() {
            const qData = questionsData[currentQuestionIndex];
            const qElement = quizArea.querySelector('.question');
            if (!qElement) return;

            switch (qData.questionType) {
                case 'fill-in-the-blank':
                    const selectedOption = qElement.querySelector('.option.selected');
                    userAnswers[currentQuestionIndex] = selectedOption ? selectedOption.dataset.value : null;
                    break;
                case 'select-multiple':
                    const selectedChecks = Array.from(qElement.querySelectorAll('.checkbox-option.selected')).map(el => el.dataset.value);
                    userAnswers[currentQuestionIndex] = selectedChecks.length > 0 ? selectedChecks : null;
                    break;
                case 'categorization':
                    const catAnswers = {};
                    qElement.querySelectorAll('.drop-zone').forEach(zone => {
                        const title = zone.dataset.categoryTitle;
                        const items = Array.from(zone.querySelectorAll('.draggable-item')).map(i => i.textContent.trim());
                        if (items.length > 0) {
                            catAnswers[title] = items;
                        }
                    });
                    userAnswers[currentQuestionIndex] = catAnswers;
                    break;
                case 'drag-blank': {
                    const zones = qElement.querySelectorAll('.blank-drop-zone');
                    if (zones.length > 1) {
                        const stored = qElement.dataset.selectedPair || null;
                        userAnswers[currentQuestionIndex] = stored && stored.length ? stored : null;
                    } else {
                        const zone = qElement.querySelector('.blank-drop-zone');
                        const dropped = zone ? zone.querySelector('.draggable-item') : null;
                        userAnswers[currentQuestionIndex] = dropped ? dropped.textContent : null;
                    }
                    break; }
                 case 'matching':
                    const matchAnswers = {};
                    qElement.querySelectorAll('.matching-premise').forEach(premise => {
                        const key = premise.querySelector('.matching-drop-zone').dataset.categoryTitle;
                        const droppedItem = premise.querySelector('.draggable-item');
                        if (droppedItem) {
                           matchAnswers[key] = droppedItem.textContent;
                        }
                    });
                    userAnswers[currentQuestionIndex] = matchAnswers;
                    break;
            }
        }

        function hasAnyAnswer(qData, answer) {
            if (answer === null) return false;
            if (qData.questionType === 'fill-in-the-blank') return typeof answer === 'string' && answer.length > 0;
            if (qData.questionType === 'select-multiple') return Array.isArray(answer) && answer.length > 0;
            if (qData.questionType === 'categorization' || qData.questionType === 'matching') {
                const keys = Object.keys(answer || {});
                for (let k of keys) {
                    if ((answer[k] || []).length > 0) return true;
                }
                return false;
            }
            if (qData.questionType === 'drag-blank') return typeof answer === 'string' && answer.length > 0;
            return false;
        }

        function getQuestionStatusByIndex(index) {
            const qData = questionsData[index];
            const ans = userAnswers[index];
            if (!hasAnyAnswer(qData, ans)) return 'empty';
            if (firstAttemptDone[index]) return firstAttemptCorrect[index] ? 'correct' : 'incorrect';
            return 'answered';
        }

        function buildOverview() {
            overviewGrid.innerHTML = '';
            questionsData.forEach((_, idx) => {
                const item = document.createElement('div');
                item.className = 'overview-item';
                item.textContent = idx + 1;
                item.addEventListener('click', () => {
                    saveAnswer();
                    currentQuestionIndex = idx;
                    showQuestion(currentQuestionIndex);
                });
                overviewGrid.appendChild(item);
            });
            updateOverview();
        }

        function updateOverview() {
            const children = Array.from(overviewGrid.children);
            children.forEach((el, idx) => {
                el.classList.remove('empty', 'answered', 'correct', 'incorrect', 'active');
                el.classList.add(getQuestionStatusByIndex(idx));
                if (idx === currentQuestionIndex) el.classList.add('active');
            });
        }

        function isAnswerCorrect(qData, answer) {
            if (!hasAnyAnswer(qData, answer)) return false;
            if (qData.questionType === 'fill-in-the-blank') {
                return answer === qData.correctAnswer;
            }
            if (qData.questionType === 'select-multiple') {
                // Map the original correct answers to new labels after shuffling
                const mappedCorrectAnswer = qData.correctAnswer.map(label => qData._answerMapping[label] || label);
                return JSON.stringify([...answer].sort()) === JSON.stringify([...mappedCorrectAnswer].sort());
            }
            if (qData.questionType === 'drag-blank') {
                return answer === qData.correctAnswer;
            }
            if (qData.questionType === 'categorization') {
                let correctCount = 0;
                const correctKeys = Object.keys(qData.correctAnswer);
                
                // Kiểm tra xem có đủ số cột không
                if (Object.keys(answer || {}).length !== correctKeys.length) {
                    return false;
                }
                
                for (let cat of correctKeys) {
                    const correctItems = Array.isArray(qData.correctAnswer[cat]) ? qData.correctAnswer[cat] : [qData.correctAnswer[cat]];
                    const userItemsRaw = answer[cat] ?? [];
                    const userItems = Array.isArray(userItemsRaw) ? userItemsRaw : [userItemsRaw];
                    
                    // Loại bỏ khoảng trắng thừa và so sánh không phân biệt thứ tự
                    const correctSorted = correctItems.map(item => item.trim()).sort();
                    const userSorted = userItems.map(item => item.trim()).sort();
                    
                    if (JSON.stringify(correctSorted) === JSON.stringify(userSorted)) {
                        correctCount++;
                    }
                }
                return correctCount === correctKeys.length;
            }
            if (qData.questionType === 'matching') {
                const correctKeys = Object.keys(qData.correctAnswer);
                for (let cat of correctKeys) {
                    const expected = qData.correctAnswer[cat];
                    const userVal = answer[cat];
                    if (!userVal || userVal !== expected) return false;
                }
                return true;
            }
            return false;
        }

        function loadAnswer(qElement, qData) {
            const answer = userAnswers[currentQuestionIndex];
            if (answer === null || (typeof answer === 'object' && Object.keys(answer).length === 0)) return;

            switch (qData.questionType) {
                case 'fill-in-the-blank':
                    const optionToSelect = qElement.querySelector(`.option[data-value="${answer}"]`);
                    if (optionToSelect) optionToSelect.classList.add('selected');
                    break;
                case 'select-multiple':
                    answer.forEach(val => {
                        const checkToSelect = qElement.querySelector(`.checkbox-option[data-value="${val}"]`);
                        if (checkToSelect) checkToSelect.classList.add('selected');
                    });
                    break;
                case 'drag-blank': {
                    const sourceItems = Array.from(qElement.querySelectorAll('.draggable-items-source .draggable-item'));
                    const zones = qElement.querySelectorAll('.blank-drop-zone');
                    if (zones.length > 1 && typeof answer === 'string') {
                        const itemToMove = sourceItems.find(el => el.textContent === answer);
                        if (itemToMove) {
                            // Simulate multi-blank placement
                            const parts = answer.split(/\s*[–-]\s*/);
                            // hide real draggable in first zone for retrieval
                            zones[0].appendChild(itemToMove);
                            itemToMove.style.display = 'none';
                            // render tokens for each blank
                            zones.forEach((bz, idx) => {
                                Array.from(bz.querySelectorAll('.token')).forEach(n => n.remove());
                                const token = document.createElement('span');
                                token.className = 'token';
                                token.textContent = parts[idx] || parts[parts.length - 1] || '';
                                bz.appendChild(token);
                            });
                            qElement.dataset.selectedPair = answer;
                        }
                    } else {
                        const zone = qElement.querySelector('.blank-drop-zone');
                        if (zone) {
                            const itemToMove = sourceItems.find(el => el.textContent === answer);
                            if (itemToMove) zone.appendChild(itemToMove);
                        }
                    }
                    break; }
                case 'categorization': {
                    const sourceItems = Array.from(qElement.querySelectorAll('.draggable-items-source .draggable-item'));
                    Object.keys(answer).forEach(containerTitle => {
                        const container = qElement.querySelector(`.drop-zone[data-category-title="${containerTitle}"]`);
                        if(container) {
                            const valsRaw = answer[containerTitle];
                            const values = Array.isArray(valsRaw) ? valsRaw : [valsRaw];
                            values.forEach(itemText => {
                                const itemToMove = sourceItems.find(el => el.textContent === itemText);
                                if (itemToMove) container.appendChild(itemToMove);
                            });
                        }
                    });
                    break; }
                case 'matching': {
                    const sourceItems = Array.from(qElement.querySelectorAll('.draggable-items-source .draggable-item'));
                    Object.keys(answer).forEach(premiseTitle => {
                        const container = qElement.querySelector(`.drop-zone[data-category-title="${premiseTitle}"]`);
                        if (container) {
                            const itemText = answer[premiseTitle];
                            const itemToMove = sourceItems.find(el => el.textContent === itemText);
                            if (itemToMove) container.appendChild(itemToMove);
                        }
                    });
                    break; }
            }
        }

        function showQuestion(index) {
            const q = questionsData[index];
            quizArea.innerHTML = ''; 
            
            // Reset touch mode state
            touchMode = false;
            selectedItem = null;

            const questionDiv = document.createElement('div');
            questionDiv.className = `question ${q.questionType}`;
            
            let contentHTML = `
                <div class="question-header">
                    <div class="question-number">${index + 1}</div>
                    <div class="question-type">${getQuestionTypeName(q.questionType)}</div>
                </div>
                <div class="question-text">${q.questionText}</div>
                ${q.imageUrl ? `<img src="${q.imageUrl}" alt="Hình minh họa" class="question-image">` : ''}
            `;

            switch (q.questionType) {
                case 'fill-in-the-blank':
                    contentHTML += '<div class="options-container">';
                    (q._optionsShuffled || q.options).forEach(opt => contentHTML += `<div class="option" data-value="${opt}">${opt}</div>`);
                    contentHTML += '</div>';
                    break;
                case 'drag-blank': {
                    // Insert a drop zone: prioritize underscores, then ellipsis, else append at end
                    const dropZoneHtml = '<span class="drop-zone blank-drop-zone" data-category-title="blank"></span>';
                    let renderedText = q.questionText;
                    if (/_+/.test(renderedText)) {
                        renderedText = renderedText.replace(/_+/g, dropZoneHtml);
                    } else if (renderedText.includes('…')) {
                        renderedText = renderedText.replace('…', dropZoneHtml);
                    } else if (renderedText.includes('...')) {
                        renderedText = renderedText.replace('...', dropZoneHtml);
                    } else {
                        renderedText = `${renderedText} ${dropZoneHtml}`;
                    }
                    const sentence = renderedText;
                    contentHTML = `
                        <div class="question-header">
                            <div class="question-number">${index + 1}</div>
                            <div class="question-type">${getQuestionTypeName(q.questionType)}</div>
                        </div>
                        <div class="question-text">${sentence}</div>
                    `;
                    contentHTML += '<p><strong>Các lựa chọn:</strong></p><div class="draggable-items-source">';
                    (q._optionsShuffled || q.options).forEach(opt => contentHTML += `<div class="draggable-item" draggable="true">${opt}</div>`);
                    contentHTML += '</div>';
                    break; }
                case 'select-multiple':
                     contentHTML += '<div class="options-container">';
                    (q._optionsShuffled || q.options).forEach(opt => {
                        const value = opt.split('.')[0];
                        contentHTML += `<div class="checkbox-option" data-value="${value}"><div class="checkbox"></div><div>${opt}</div></div>`;
                    });
                    contentHTML += '</div>';
                    break;
                case 'categorization':
                    contentHTML += '<div class="categories-container">';
                    (q._categoriesShuffled || Object.keys(q.correctAnswer)).forEach(cat => {
                        const visibleCat = formatVisibleText(cat);
                        contentHTML += `<div class="category"><div class="category-title">${visibleCat}</div><div class="drop-zone" data-category-title="${cat}"></div></div>`;
                    });
                    contentHTML += '</div><p><strong>Các lựa chọn:</strong></p>';
                    if (isTouchDevice) {
                        contentHTML += '<p class="mobile-hint"><small>💡 <strong>Hướng dẫn:</strong> Chạm để chọn, chạm vào cột để đặt. Chạm vào góc trên bên phải (✕) để gỡ đáp án.</small></p>';
                    }
                    contentHTML += '<div class="draggable-items-source">';
                    (q._optionsShuffled || q.options).forEach(opt => contentHTML += `<div class="draggable-item" draggable="true">${opt}</div>`);
                    contentHTML += '</div>';
                    break;
                case 'matching':
                    (q._premisesShuffled || Object.keys(q.correctAnswer)).forEach(premise => {
                        const visiblePremise = formatVisibleText(premise);
                        contentHTML += `<div class="matching-premise"><span class="matching-premise-text">${visiblePremise}</span><div class="drop-zone matching-drop-zone" data-category-title="${premise}"></div></div>`
                    });
                    contentHTML += '<p><strong>Các lựa chọn:</strong></p><div class="draggable-items-source">';
                    (q._optionsShuffled || q.options).forEach(opt => contentHTML += `<div class="draggable-item" draggable="true">${opt}</div>`);
                    contentHTML += '</div>';
                    break;
            }
            questionDiv.innerHTML = contentHTML;
            quizArea.appendChild(questionDiv);

            // feedback placeholder
            const fb = document.createElement('div');
            fb.id = 'feedback';
            fb.className = 'feedback';
            quizArea.appendChild(fb);

            loadAnswer(questionDiv, q);
            attachEventListenersForCurrentQuestion();
            updateNavigation();
            updateOverview();

            // restore feedback state
            if (firstAttemptDone[index]) {
                const answer = userAnswers[index];
                const ok = isAnswerCorrect(q, answer);
                renderFeedback(ok);
                if (canProceed[index]) disableInteractions(questionDiv);
            } else {
                renderFeedback(null);
            }
        }

        function enableTouchMode(qElement, draggables, dropZones, sourceContainers) {
            touchMode = true;
            selectedItem = null;
            
            // Add touch mode classes
            draggables.forEach(item => item.classList.add('touch-mode'));
            dropZones.forEach(zone => zone.classList.add('touch-mode'));
            
            // Handle item selection
            draggables.forEach(item => {
                item.addEventListener('click', () => {
                    if (selectedItem) selectedItem.classList.remove('selected');
                    selectedItem = item;
                    item.classList.add('selected');
                    
                    // Visual feedback
                    dropZones.forEach(zone => zone.classList.add('touch-mode'));
                });
            });
            
            // Handle drop zone clicks
            dropZones.forEach(zone => {
                zone.addEventListener('click', (e) => {
                    // If clicking on an item inside the zone, handle double-tap logic
                    if (e.target.classList.contains('draggable-item') && e.target.parentElement === zone) {
                        return; // Let the double-tap handler deal with this
                    }
                    
                    // If clicking on empty zone and have selected item
                    if (!selectedItem) return;
                    
                    // Special handling for matching (only one item per zone)
                    if (zone.classList.contains('matching-drop-zone') && zone.children.length > 0) {
                        const sourceContainer = qElement.querySelector('.draggable-items-source');
                        sourceContainer.appendChild(zone.firstElementChild);
                    }
                    
                    // Special handling for drag-blank with multiple blanks
                    if (qElement.classList.contains('drag-blank') && zone.classList.contains('blank-drop-zone')) {
                        const blanks = qElement.querySelectorAll('.blank-drop-zone');
                        if (blanks.length > 1) {
                            const pairText = selectedItem.textContent.trim();
                            const parts = pairText.split(/\s*[–-]\s*/);
                            
                            // Hide the real item in first blank
                            blanks[0].appendChild(selectedItem);
                            selectedItem.style.display = 'none';
                            
                            // Create tokens for each blank
                            blanks.forEach((bz, idx) => {
                                Array.from(bz.querySelectorAll('.token')).forEach(n => n.remove());
                                const token = document.createElement('span');
                                token.className = 'token';
                                token.textContent = parts[idx] || parts[parts.length - 1] || '';
                                bz.appendChild(token);
                            });
                            qElement.dataset.selectedPair = pairText;
                        } else {
                            zone.appendChild(selectedItem);
                        }
                    } else {
                        zone.appendChild(selectedItem);
                    }
                    
                    // Add remove button for mobile
                    if (isTouchDevice) {
                        const itemToAdd = selectedItem;
                        itemToAdd.classList.add('remove-btn');
                        itemToAdd.addEventListener('click', (e) => {
                            // Check if clicking on the remove button (✕)
                            const rect = e.target.getBoundingClientRect();
                            const clickX = e.clientX - rect.left;
                            const clickY = e.clientY - rect.top;
                            
                            // If click is near the top-right corner (where ✕ is)
                            if (clickX > rect.width - 25 && clickY < 25) {
                                e.stopPropagation();
                                const sourceContainer = qElement.querySelector('.draggable-items-source');
                                if (sourceContainer) {
                                    itemToAdd.classList.remove('remove-btn');
                                    sourceContainer.appendChild(itemToAdd);
                                    if (selectedItem === itemToAdd) {
                                        selectedItem.classList.remove('selected');
                                        selectedItem = null;
                                    }
                                    saveAnswer();
                                    updateOverview();
                                }
                            }
                        });
                    }
                    
                    selectedItem.classList.remove('selected');
                    selectedItem = null;
                    saveAnswer();
                    updateOverview();
                });
            });
            
            // Handle source container clicks (return items)
            sourceContainers.forEach(source => {
                source.addEventListener('click', (e) => {
                    if (e.target.classList.contains('draggable-item')) {
                        if (selectedItem) selectedItem.classList.remove('selected');
                        selectedItem = e.target;
                        selectedItem.classList.add('selected');
                    }
                });
            });
            
            // Add long press to remove items from drop zones
            let pressTimer = null;
            
            dropZones.forEach(zone => {
                zone.addEventListener('click', (e) => {
                    // If clicking on an item inside the zone (not the zone itself)
                    if (e.target.classList.contains('draggable-item') && e.target.parentElement === zone) {
                        // Single tap - select the item
                        if (selectedItem) selectedItem.classList.remove('selected');
                        selectedItem = e.target;
                        selectedItem.classList.add('selected');
                    }
                });
                
                // Long press to remove items
                zone.addEventListener('touchstart', (e) => {
                    if (e.target.classList.contains('draggable-item') && e.target.parentElement === zone) {
                        pressTimer = setTimeout(() => {
                            // Long press detected - remove the item
                            const sourceContainer = qElement.querySelector('.draggable-items-source');
                            if (sourceContainer) {
                                sourceContainer.appendChild(e.target);
                                if (selectedItem === e.target) {
                                    selectedItem.classList.remove('selected');
                                    selectedItem = null;
                                }
                                saveAnswer();
                                updateOverview();
                                
                                // Show visual feedback
                                e.target.style.transform = 'scale(1.1)';
                                setTimeout(() => e.target.style.transform = '', 200);
                            }
                        }, 800); // 800ms long press
                    }
                });
                
                zone.addEventListener('touchend', () => {
                    if (pressTimer) {
                        clearTimeout(pressTimer);
                        pressTimer = null;
                    }
                });
                
                zone.addEventListener('touchmove', () => {
                    if (pressTimer) {
                        clearTimeout(pressTimer);
                        pressTimer = null;
                    }
                });
            });
        }

        function attachEventListenersForCurrentQuestion() {
            const qElement = quizArea.querySelector('.question');
            if(!qElement) return;

            qElement.querySelectorAll('.option').forEach(opt => {
                opt.addEventListener('click', () => {
                    qElement.querySelectorAll('.option').forEach(o => o.classList.remove('selected'));
                    opt.classList.add('selected');
                });
            });

            qElement.querySelectorAll('.checkbox-option').forEach(opt => {
                opt.addEventListener('click', () => opt.classList.toggle('selected'));
            });

            const draggables = qElement.querySelectorAll('.draggable-item');
            const dropZones = qElement.querySelectorAll('.drop-zone');
            const sourceContainers = qElement.querySelectorAll('.draggable-items-source');
            
            // Enable touch mode for drag & drop questions
            if (isTouchDevice && (qElement.classList.contains('categorization') || 
                qElement.classList.contains('matching') || qElement.classList.contains('drag-blank'))) {
                enableTouchMode(qElement, draggables, dropZones, sourceContainers);
            } else {
                // Regular drag & drop for desktop
            draggables.forEach(draggable => {
                draggable.addEventListener('dragstart', () => draggable.classList.add('dragging'));
                draggable.addEventListener('dragend', () => draggable.classList.remove('dragging'));
            });
            }
            // Only add drag & drop listeners if not in touch mode
            if (!touchMode) {
            dropZones.forEach(zone => {
                zone.addEventListener('dragover', e => { e.preventDefault(); zone.classList.add('drag-over'); });
                zone.addEventListener('dragleave', () => zone.classList.remove('drag-over'));
                zone.addEventListener('drop', e => {
                    e.preventDefault();
                    zone.classList.remove('drag-over');
                    const dragging = document.querySelector('.dragging');
                    // Allow only one item in matching drop zones
                    if (zone.classList.contains('matching-drop-zone') && zone.children.length > 0) {
                        const sourceContainer = qElement.querySelector('.draggable-items-source');
                        sourceContainer.appendChild(zone.firstElementChild);
                    }
                        // Special handling for drag-blank with multiple blanks
                        if (qElement.classList.contains('drag-blank') && zone.classList.contains('blank-drop-zone')) {
                            const blanks = qElement.querySelectorAll('.blank-drop-zone');
                            if (blanks.length > 1 && dragging) {
                                const pairText = dragging.textContent.trim();
                                const parts = pairText.split(/\s*[–-]\s*/);
                                // hide the real draggable in the first blank for later retrieval
                                blanks[0].appendChild(dragging);
                                dragging.style.display = 'none';
                                blanks.forEach((bz, idx) => {
                                    Array.from(bz.querySelectorAll('.token')).forEach(n => n.remove());
                                    const token = document.createElement('span');
                                    token.className = 'token';
                                    token.textContent = parts[idx] || parts[parts.length - 1] || '';
                                    bz.appendChild(token);
                                });
                                qElement.dataset.selectedPair = pairText;
                                saveAnswer();
                                updateOverview();
                                return;
                            }
                        }
                    if (dragging) zone.appendChild(dragging);
                    saveAnswer();
                    updateOverview();
                });
            });
            }

            // Allow dragging answers back to the source container (only if not in touch mode)
            if (!touchMode) {
                sourceContainers.forEach(source => {
                    source.addEventListener('dragover', e => { e.preventDefault(); source.classList.add('drag-over'); });
                    source.addEventListener('dragleave', () => source.classList.remove('drag-over'));
                    source.addEventListener('drop', e => {
                        e.preventDefault();
                        source.classList.remove('drag-over');
                        const dragging = document.querySelector('.dragging');
                        if (qElement.classList.contains('drag-blank')) {
                            const blanks = qElement.querySelectorAll('.blank-drop-zone');
                            if (blanks.length > 1) {
                                // return hidden draggable to source and clear tokens
                                const hidden = blanks[0].querySelector('.draggable-item');
                                if (hidden) {
                                    hidden.style.display = '';
                                    source.appendChild(hidden);
                                }
                                blanks.forEach(bz => Array.from(bz.querySelectorAll('.token')).forEach(n => n.remove()));
                                delete qElement.dataset.selectedPair;
                            }
                        }
                        if (dragging) source.appendChild(dragging);
                        saveAnswer();
                        updateOverview();
                    });
                });
            }
        }

        function disableInteractions(qElement) {
            qElement.querySelectorAll('.option, .checkbox-option, .draggable-item').forEach(el => {
                el.style.pointerEvents = 'none';
                el.style.opacity = '0.8';
            });
        }

        function renderFeedback(ok) {
            const fb = document.getElementById('feedback');
            if (!fb) return;
            fb.classList.remove('ok','err');
            if (ok === true) {
                fb.textContent = 'Chính xác! Bạn có thể sang câu tiếp theo.';
                fb.classList.add('ok');
                playSuccessSound();
            } else if (ok === false) {
                fb.textContent = 'Chưa đúng. Hãy điều chỉnh và chốt lại đáp án!';
                fb.classList.add('err');
                playErrorSound();
            } else {
                fb.textContent = '';
            }
        }

        function updateNavigation() {
            progressText.textContent = `Câu ${currentQuestionIndex + 1} / ${questionsData.length}`;
            progressBar.style.width = `${((currentQuestionIndex + 1) / questionsData.length) * 100}%`;
            prevBtn.disabled = currentQuestionIndex === 0;

            // Control next button
            nextBtn.disabled = !canProceed[currentQuestionIndex];
            if (currentQuestionIndex === questionsData.length - 1) {
                nextBtn.textContent = 'Nộp bài';
                nextBtn.style.background = '#28a745';
                nextBtn.style.borderColor = '#28a745';
                nextBtn.style.color = 'white';
            } else {
                nextBtn.textContent = 'Câu sau';
                nextBtn.style.background = '';
                nextBtn.style.borderColor = '';
                nextBtn.style.color = '';
            }
        }

        function showResults() {
            let score = 0;
            firstAttemptCorrect.forEach(ok => { if (ok) score++; });
            
            quizArea.style.display = 'none';
            document.querySelector('.quiz-navigation').style.display = 'none';
            document.querySelector('.progress-container').style.display = 'none';
            document.getElementById('results').style.display = 'block';
            document.getElementById('score').textContent = `Kết quả: ${score} / ${questionsData.length}`;
        }

        nextBtn.addEventListener('click', () => {
            if (!canProceed[currentQuestionIndex]) return;
            if (currentQuestionIndex < questionsData.length - 1) {
                currentQuestionIndex++;
                showQuestion(currentQuestionIndex);
            } else {
                showResults();
            }
        });

        prevBtn.addEventListener('click', () => {
            saveAnswer();
            if (currentQuestionIndex > 0) {
                currentQuestionIndex--;
                showQuestion(currentQuestionIndex);
            }
        });

        lockBtn.addEventListener('click', () => {
            saveAnswer();
            const qData = questionsData[currentQuestionIndex];
            const answer = userAnswers[currentQuestionIndex];
            if (!hasAnyAnswer(qData, answer)) {
                renderFeedback(false);
                return;
            }
            const ok = isAnswerCorrect(qData, answer);
            // Record first attempt only once
            if (!firstAttemptDone[currentQuestionIndex]) {
                firstAttemptDone[currentQuestionIndex] = true;
                firstAttemptCorrect[currentQuestionIndex] = ok;
            }
            if (ok) {
                canProceed[currentQuestionIndex] = true;
                const qElement = quizArea.querySelector('.question');
                if (qElement) disableInteractions(qElement);
            }
            renderFeedback(ok);
            updateNavigation();
            updateOverview();
        });

        // Keyboard: Enter to lock; if allowed, Enter goes next
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                e.preventDefault();
                if (canProceed[currentQuestionIndex]) {
                    // advance or submit
                    if (currentQuestionIndex < questionsData.length - 1) {
                        currentQuestionIndex++;
                        showQuestion(currentQuestionIndex);
                    } else {
                        showResults();
                    }
                } else {
                    lockBtn.click();
                }
            }
        });

        buildOverview();
        showQuestion(currentQuestionIndex);
    });
    </script>
</body>
</html>


